import { execFileSync } from 'node:child_process';
import { existsSync, readFileSync, writeFileSync } from 'node:fs';
import { resolve } from 'node:path';
import { Buffer } from 'node:buffer';
import { createHash } from 'node:crypto';

declare const Bun: {
  serve: (opts: { port: number; fetch: (req: Request) => Promise<Response> | Response }) => unknown;
};

type Guess4 = [number, number, number, number];
type Salt16 = [
  number, number, number, number,
  number, number, number, number,
  number, number, number, number,
  number, number, number, number
];

type ProveRequest = {
  session_id: number;
  guess_id: number;
  commitment: string;
  guess: Guess4;
  exact: number;
  partial: number;
  secret: Guess4;
  salt: Salt16;
};

let requestCounter = 0;

function assertCond(condition: boolean, message: string): asserts condition {
  if (!condition) throw new Error(message);
}

function assertArray(name: string, values: number[], len: number, max: number) {
  assertCond(values.length === len, `${name} must have length ${len}`);
  for (const v of values) {
    assertCond(Number.isInteger(v) && v >= 0 && v <= max, `${name} contains invalid value ${v}`);
  }
}

function validateProveInput(input: ProveRequest) {
  assertCond(Number.isInteger(input.session_id) && input.session_id >= 0, 'session_id must be non-negative integer');
  assertCond(Number.isInteger(input.guess_id) && input.guess_id >= 0, 'guess_id must be non-negative integer');
  assertCond(Number.isInteger(input.exact) && input.exact >= 0 && input.exact <= 4, 'exact must be 0..4');
  assertCond(Number.isInteger(input.partial) && input.partial >= 0 && input.partial <= 4, 'partial must be 0..4');
  assertCond(input.exact + input.partial <= 4, 'exact + partial must be <= 4');
  assertCond(/^\d+$/.test(input.commitment), 'commitment must be decimal string');
  assertArray('guess', input.guess, 4, 6);
  assertArray('secret', input.secret, 4, 6);
  assertArray('salt', input.salt, 16, 255);
}

function packGuess(guess: Guess4): number {
  return ((guess[0] << 24) | (guess[1] << 16) | (guess[2] << 8) | guess[3]) >>> 0;
}

function toTomlArray(values: number[]): string {
  return `[${values.map((v) => `"${v}"`).join(', ')}]`;
}

function buildProverToml(input: ProveRequest): string {
  return [
    '# Auto-generated by zk-server.ts',
    `session_id = "${input.session_id}"`,
    `guess_id = "${input.guess_id}"`,
    `commitment = "${input.commitment}"`,
    `guess_packed = "${packGuess(input.guess)}"`,
    `exact = "${input.exact}"`,
    `partial = "${input.partial}"`,
    `salt = ${toTomlArray(input.salt)}`,
    `secret = ${toTomlArray(input.secret)}`,
    `guess = ${toTomlArray(input.guess)}`,
    '',
  ].join('\n');
}

function runCmd(cmd: string, args: string[], cwd: string) {
  const startedAt = Date.now();
  console.log(`[zk-server] run ${cmd} ${args.join(' ')}`);
  try {
    execFileSync(cmd, args, { cwd, stdio: 'pipe' });
    console.log(`[zk-server] done ${cmd} (${Date.now() - startedAt}ms)`);
  } catch (error) {
    console.error(`[zk-server] failed ${cmd} (${Date.now() - startedAt}ms)`, String(error));
    throw error;
  }
}

function resolveBinary(name: 'nargo' | 'bb'): string {
  const envOverride = name === 'nargo' ? process.env.NARGO_BIN : process.env.BB_BIN;
  if (envOverride && existsSync(envOverride)) return envOverride;

  const pathEntries = (process.env.PATH || '').split(':').filter(Boolean);
  for (const entry of pathEntries) {
    const candidate = resolve(entry, name);
    if (existsSync(candidate)) return candidate;
  }

  const home = process.env.HOME || '';
  const fallbacks = name === 'nargo'
    ? [
        resolve(home, '.nargo/bin/nargo'),
        resolve(home, '.local/bin/nargo'),
      ]
    : [
        resolve(home, '.bb/bb'),
        resolve(home, '.local/bin/bb'),
      ];

  for (const candidate of fallbacks) {
    if (existsSync(candidate)) return candidate;
  }

  throw new Error(
    `${name} binary not found. Set ${name === 'nargo' ? 'NARGO_BIN' : 'BB_BIN'} or add ${name} to PATH.`,
  );
}

function findCircuitDir(): string {
  const candidates = [
    resolve(process.cwd(), 'zk/my-game-circuit'),
    resolve(process.cwd(), '../zk/my-game-circuit'),
    resolve(process.cwd(), '../../zk/my-game-circuit'),
  ];
  for (const p of candidates) {
    if (existsSync(resolve(p, 'Nargo.toml'))) return p;
  }
  throw new Error('Could not find zk/my-game-circuit');
}

function buildProofBlob(publicInputs: Buffer, proof: Buffer): Buffer {
  assertCond(publicInputs.length % 32 === 0, 'public_inputs length must be multiple of 32');
  assertCond(proof.length % 32 === 0, 'proof length must be multiple of 32');
  const totalFields = (publicInputs.length + proof.length) / 32;
  const header = Buffer.alloc(4);
  header.writeUInt32BE(totalFields, 0);
  return Buffer.concat([header, publicInputs, proof]);
}

function blakeCommitment(secret: Guess4, salt: Salt16): string {
  const preimage = Buffer.from([...secret, ...salt]);
  const digest = createHash('blake2s256').update(preimage).digest();
  let value = 0n;
  for (let i = 0; i < 31; i++) {
    value = (value << 8n) + BigInt(digest[i]);
  }
  return value.toString();
}

function prove(input: ProveRequest, requestId: string): Buffer {
  console.log(`[zk-server][${requestId}] prove start`, {
    session_id: input.session_id,
    guess_id: input.guess_id,
    exact: input.exact,
    partial: input.partial,
    commitment_digits: input.commitment.length,
  });
  validateProveInput(input);
  console.log(`[zk-server][${requestId}] input validated`);
  const circuitDir = findCircuitDir();
  console.log(`[zk-server][${requestId}] circuit dir: ${circuitDir}`);
  const nargoBin = resolveBinary('nargo');
  const bbBin = resolveBinary('bb');
  console.log(`[zk-server][${requestId}] binaries`, { nargoBin, bbBin });
  const proverTomlPath = resolve(circuitDir, 'Prover.toml');
  const previousToml = existsSync(proverTomlPath) ? readFileSync(proverTomlPath, 'utf8') : null;
  try {
    console.log(`[zk-server][${requestId}] writing Prover.toml`);
    writeFileSync(proverTomlPath, buildProverToml(input), 'utf8');
    console.log(`[zk-server][${requestId}] running nargo execute`);
    runCmd(nargoBin, ['execute'], circuitDir);
    console.log(`[zk-server][${requestId}] running bb prove`);
    runCmd(bbBin, ['prove', '-b', 'target/my_game.json', '-w', 'target/my_game.gz', '-o', 'target', '--scheme', 'ultra_honk', '--oracle_hash', 'keccak'], circuitDir);
    console.log(`[zk-server][${requestId}] reading proof artifacts`);
    const proof = Buffer.from(readFileSync(resolve(circuitDir, 'target/proof')));
    const publicInputs = Buffer.from(readFileSync(resolve(circuitDir, 'target/public_inputs')));
    console.log(`[zk-server][${requestId}] prove done`, {
      proof_bytes: proof.length,
      public_inputs_bytes: publicInputs.length,
    });
    return buildProofBlob(publicInputs, proof);
  } finally {
    if (previousToml !== null) {
      writeFileSync(proverTomlPath, previousToml, 'utf8');
      console.log(`[zk-server][${requestId}] restored previous Prover.toml`);
    }
  }
}

function json(data: unknown, status = 200): Response {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      'content-type': 'application/json',
      'access-control-allow-origin': '*',
      'access-control-allow-methods': 'POST, GET, OPTIONS',
      'access-control-allow-headers': 'content-type',
    },
  });
}

const port = Number(process.env.ZK_SERVER_PORT || 8787);
const detectedNargo = (() => {
  try {
    return resolveBinary('nargo');
  } catch {
    return '(not found)';
  }
})();
const detectedBb = (() => {
  try {
    return resolveBinary('bb');
  } catch {
    return '(not found)';
  }
})();

Bun.serve({
  port,
  async fetch(req: Request) {
    const requestId = `req-${++requestCounter}`;
    const reqUrl = new URL(req.url);
    console.log(`[zk-server][${requestId}] request ${req.method} ${reqUrl.pathname}`);
    if (req.method === 'OPTIONS') return json({ ok: true });

    try {
      const url = reqUrl;
      if (req.method === 'GET' && url.pathname === '/health') {
        console.log(`[zk-server][${requestId}] health ok`);
        return json({ ok: true, service: 'zk-server', port });
      }

      if (req.method === 'POST' && url.pathname === '/commitment') {
        const body = await req.json() as { secret: Guess4; salt: Salt16 };
        console.log(`[zk-server][${requestId}] commitment request received`, {
          secret_len: body.secret?.length,
          salt_len: body.salt?.length,
        });
        assertArray('secret', body.secret, 4, 6);
        assertArray('salt', body.salt, 16, 255);
        const commitment = blakeCommitment(body.secret, body.salt);
        console.log(`[zk-server][${requestId}] commitment done`, { commitment_digits: commitment.length });
        return json({ commitment });
      }

      if (req.method === 'POST' && url.pathname === '/prove') {
        const body = await req.json() as ProveRequest;
        console.log(`[zk-server][${requestId}] prove request received`, {
          session_id: body.session_id,
          guess_id: body.guess_id,
          exact: body.exact,
          partial: body.partial,
        });
        const proofBlob = prove(body, requestId);
        console.log(`[zk-server][${requestId}] prove response`, { proof_blob_bytes: proofBlob.length });
        return json({
          ok: true,
          proof_blob_base64: proofBlob.toString('base64'),
          proof_blob_hex: proofBlob.toString('hex'),
        });
      }

      return json({ error: 'not_found' }, 404);
    } catch (error) {
      console.error(`[zk-server][${requestId}] request error`, String(error));
      return json({ error: String(error) }, 400);
    }
  },
});

console.log(`zk_server listening on http://localhost:${port}`);
console.log(`zk_server binaries: nargo=${detectedNargo}, bb=${detectedBb}`);
