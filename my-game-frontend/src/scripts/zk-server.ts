import { execFileSync } from 'node:child_process';
import { existsSync, readFileSync, writeFileSync } from 'node:fs';
import { resolve } from 'node:path';
import { Buffer } from 'node:buffer';
import { createHash } from 'node:crypto';

declare const Bun: {
  serve: (opts: { port: number; fetch: (req: Request) => Promise<Response> | Response }) => unknown;
};

type Guess4 = [number, number, number, number];
type Salt16 = [
  number, number, number, number,
  number, number, number, number,
  number, number, number, number,
  number, number, number, number
];

type ProveRequest = {
  session_id: number;
  guess_id: number;
  commitment: string;
  guess: Guess4;
  exact: number;
  partial: number;
  secret: Guess4;
  salt: Salt16;
};

function assertCond(condition: boolean, message: string): asserts condition {
  if (!condition) throw new Error(message);
}

function assertArray(name: string, values: number[], len: number, max: number) {
  assertCond(values.length === len, `${name} must have length ${len}`);
  for (const v of values) {
    assertCond(Number.isInteger(v) && v >= 0 && v <= max, `${name} contains invalid value ${v}`);
  }
}

function validateProveInput(input: ProveRequest) {
  assertCond(Number.isInteger(input.session_id) && input.session_id >= 0, 'session_id must be non-negative integer');
  assertCond(Number.isInteger(input.guess_id) && input.guess_id >= 0, 'guess_id must be non-negative integer');
  assertCond(Number.isInteger(input.exact) && input.exact >= 0 && input.exact <= 4, 'exact must be 0..4');
  assertCond(Number.isInteger(input.partial) && input.partial >= 0 && input.partial <= 4, 'partial must be 0..4');
  assertCond(input.exact + input.partial <= 4, 'exact + partial must be <= 4');
  assertCond(/^\d+$/.test(input.commitment), 'commitment must be decimal string');
  assertArray('guess', input.guess, 4, 9);
  assertArray('secret', input.secret, 4, 9);
  assertArray('salt', input.salt, 16, 255);
}

function packGuess(guess: Guess4): number {
  return ((guess[0] << 24) | (guess[1] << 16) | (guess[2] << 8) | guess[3]) >>> 0;
}

function toTomlArray(values: number[]): string {
  return `[${values.map((v) => `"${v}"`).join(', ')}]`;
}

function buildProverToml(input: ProveRequest): string {
  return [
    '# Auto-generated by zk-server.ts',
    `session_id = "${input.session_id}"`,
    `guess_id = "${input.guess_id}"`,
    `commitment = "${input.commitment}"`,
    `guess_packed = "${packGuess(input.guess)}"`,
    `exact = "${input.exact}"`,
    `partial = "${input.partial}"`,
    `salt = ${toTomlArray(input.salt)}`,
    `secret = ${toTomlArray(input.secret)}`,
    `guess = ${toTomlArray(input.guess)}`,
    '',
  ].join('\n');
}

function runCmd(cmd: string, args: string[], cwd: string) {
  execFileSync(cmd, args, { cwd, stdio: 'pipe' });
}

function findCircuitDir(): string {
  const candidates = [
    resolve(process.cwd(), 'zk/my-game-circuit'),
    resolve(process.cwd(), '../zk/my-game-circuit'),
    resolve(process.cwd(), '../../zk/my-game-circuit'),
  ];
  for (const p of candidates) {
    if (existsSync(resolve(p, 'Nargo.toml'))) return p;
  }
  throw new Error('Could not find zk/my-game-circuit');
}

function buildProofBlob(publicInputs: Buffer, proof: Buffer): Buffer {
  assertCond(publicInputs.length % 32 === 0, 'public_inputs length must be multiple of 32');
  assertCond(proof.length % 32 === 0, 'proof length must be multiple of 32');
  const totalFields = (publicInputs.length + proof.length) / 32;
  const header = Buffer.alloc(4);
  header.writeUInt32BE(totalFields, 0);
  return Buffer.concat([header, publicInputs, proof]);
}

function blakeCommitment(secret: Guess4, salt: Salt16): string {
  const preimage = Buffer.from([...secret, ...salt]);
  const digest = createHash('blake2s256').update(preimage).digest();
  let value = 0n;
  for (let i = 0; i < 31; i++) {
    value = (value << 8n) + BigInt(digest[i]);
  }
  return value.toString();
}

function prove(input: ProveRequest): Buffer {
  validateProveInput(input);
  const circuitDir = findCircuitDir();
  const proverTomlPath = resolve(circuitDir, 'Prover.toml');
  const previousToml = existsSync(proverTomlPath) ? readFileSync(proverTomlPath, 'utf8') : null;
  try {
    writeFileSync(proverTomlPath, buildProverToml(input), 'utf8');
    runCmd('nargo', ['execute'], circuitDir);
    runCmd('bb', ['prove', '-b', 'target/my_game.json', '-w', 'target/my_game.gz', '-o', 'target', '--scheme', 'ultra_honk', '--oracle_hash', 'keccak'], circuitDir);
    const proof = Buffer.from(readFileSync(resolve(circuitDir, 'target/proof')));
    const publicInputs = Buffer.from(readFileSync(resolve(circuitDir, 'target/public_inputs')));
    return buildProofBlob(publicInputs, proof);
  } finally {
    if (previousToml !== null) writeFileSync(proverTomlPath, previousToml, 'utf8');
  }
}

function json(data: unknown, status = 200): Response {
  return new Response(JSON.stringify(data), {
    status,
    headers: {
      'content-type': 'application/json',
      'access-control-allow-origin': '*',
      'access-control-allow-methods': 'POST, GET, OPTIONS',
      'access-control-allow-headers': 'content-type',
    },
  });
}

const port = Number(process.env.ZK_SERVER_PORT || 8787);

Bun.serve({
  port,
  async fetch(req: Request) {
    if (req.method === 'OPTIONS') return json({ ok: true });

    try {
      const url = new URL(req.url);
      if (req.method === 'GET' && url.pathname === '/health') {
        return json({ ok: true, service: 'zk-server', port });
      }

      if (req.method === 'POST' && url.pathname === '/commitment') {
        const body = await req.json() as { secret: Guess4; salt: Salt16 };
        assertArray('secret', body.secret, 4, 9);
        assertArray('salt', body.salt, 16, 255);
        return json({ commitment: blakeCommitment(body.secret, body.salt) });
      }

      if (req.method === 'POST' && url.pathname === '/prove') {
        const body = await req.json() as ProveRequest;
        const proofBlob = prove(body);
        return json({
          ok: true,
          proof_blob_base64: proofBlob.toString('base64'),
          proof_blob_hex: proofBlob.toString('hex'),
        });
      }

      return json({ error: 'not_found' }, 404);
    } catch (error) {
      return json({ error: String(error) }, 400);
    }
  },
});

console.log(`zk_server listening on http://localhost:${port}`);
